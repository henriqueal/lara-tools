aspectdef dse_algo

  // ==================================================================
  // Input arguments
  // ==================================================================

  input
    exploreParams = [], frontend, compile, execute_and_report, compile_execute_and_report, check_sequence_is_valid, add_timing, cleanall, minimumLat = 100, sequences, iterations, maxwidth, optimLevelsLatency, nr, selection;
  end

  output
    bestSeq, bestSeqLatency, total_steps;
  end


  function isnooptim(x){
    if(x !== "NOOPTIM") {
      return true;
    }
  }

  var optimLevel = ""; //"-O0";   // No optimization
  var latencyRef = optimLevelsLatency[0];


  if(latencyRef == 0) {
    for(var i=0; i<optimLevelsLatency.length; i++) {
      if(optimLevelsLatency[i] > 0) {
        latencyRef = optimLevelsLatency[i];
      }
    }
  }


  var applyunroll = "0";  // Não posso activar isto, pois isto está feito para o REFLECTC
  var maxGen="1000000"; // estava 30, mas isto estava a limitar o numero de iteraçoes
  var maxCount = "25";
  var popSize="30"; // "300";
  var crossRate="60";
  var mutationRate="40";
  var tour="3";
  
  total_steps = 0;

  // Stop criterion arguments
  var deltaMin = 1;  // joined stop criterion

  // Other arguments
  var vezesTot = 4; // Number of tries to generate new individual

  // ==================================================================
  // Design space coverage
  // ==================================================================
  var exploreParamSize = exploreParams.length;
  
  // Adjust parameters for percentage
  crossRate = crossRate/100;
  mutationRate = mutationRate/100;
  
  // Unrolling parameters
  var loopranks = [];  // ["1","1:1","2","2:1"];  // FOR TEST ONLY
  var looprankSize = 0;  // loopranks.length;
  var loopfactors = [];  // ["1", "2", "4", "0"];

  // ==================================================================
  // ********************** Genetic Algorithm Code ********************
  // ==================================================================

  var speedup;   // Used to computation the speedup of an individual

  // Population array variables
  var histPop = [];
  var histSize = 0;
  var pop = [];
  var popId;    // Population index (individual location)

  // Define the maximum size of population
  var popTotal = Math.round(popSize * (1+crossRate));
  if (popTotal%2 == 1) {
    popTotal++;
  }

  // ***************************************************************************************************************
  // Create other individuals of initial population


  var transformSubsetSize = Math.ceil(popSize/maxwidth); // Increment interval of the optimizations number
  var geneMax = 1;

  //println("explore");
  //println(exploreParamSize);

  //GERA A POPULACAO INICIAL
  pop = generateInitialPopulation(popSize, exploreParams, exploreParamSize, transformSubsetSize, isnooptim, compile_execute_and_report);
  
  // Store individual in historical array
  //histPop[histSize] = indiv_copy(pop[id]);
  //histSize++;

  //println("id:: " + id );
  //println(population[id].fitness + ";" + population[id].chromosomeSize + ";" + population[id].chromosome.join(","));
  //println("");

  // Sort the population by fitness and size of the transformations size

  //println("The best is: ");
  //pop.sort(by('fitness', by('chromosomeSize')));
  //println(pop[0].fitness + ";" + pop[0].chromosomeSize + ";" + pop[0].chromosome.join(","));
	//println("");
  var bestlatency = pop[0].fitness; // Store the best latency
  // ***************************************************************************************************************
  //println(bestlatency);
  //println("populacao size");
  //println("pop size: " + pop.length);

  // Create the population of childs
  for (popId = popSize; popId < popTotal; popId++){
    pop[popId] = indiv_maker();
  }

  // ==================================================================
  // Interative step (generations)
  // ==================================================================
  var counterSpeedup = 1;
  var counterGen;

  maxGen=5;
  for (counterGen = 0; counterGen < maxGen; counterGen++) {
    var randNumber;

    // Crossover operator
    //var novo = 0;
    var child1;
    for (child1 = popSize; child1 < popTotal; child1 = child1+2) {
      var child2 = child1++;

      //02-beg SELECTION ---------------------------------------------------------------------------------
      var parent1, parent2;
      if(selection == "tour"){        
        parent2 = tournment(pop, popSize, tour);
      } else if (selection == "roulette"){
        parent2 = roulette(pop, popSize);
      }

      parent1=indiv_copy(parent2);

      do {
        if(selection == "tour"){
          parent2 = tournment(pop, popSize, tour);
        } else if (selection == "roulette"){
          parent2 = roulette(pop, popSize);
        } 
      } while (parent1 == parent2);

      //02-end ------------------------------------------------------------------------------------------

      //03-beg Crossover --------------------------------------------------------------------------------
      
      var childrens = [];
      childrens = crossoverTwoPoints(pop, parent1, parent2);
      pop[child1] = indiv_copy(childrens[0]);
      pop[child2] = indiv_copy(childrens[1]);
      
      //03-end ------------------------------------------------------------------------------------------
      
    }
    

    // Mutation operator (only children individuals)
    var novo = 0;
    for (popId = popSize; popId < popTotal; popId++) {
      // Mutation
      if (Math.random() <= mutationRate) {
        mutation(looprankSize, loopfactors, exploreParams[Math.floor(Math.random()*(exploreParamSize-0.1))], pop[popId], pop[popId].chromosome.length, applyunroll, maxwidth);
      }

      // Verify if individual already exists
      var vezes = 0;
      do {
        if (indiv_finder(histPop, pop[popId]) > -1) {
          var x;
          for (x=0; x < (vezes+counterSpeedup); x++) {
            mutation(looprankSize, loopfactors, exploreParams[Math.floor(Math.random()*(exploreParamSize-0.1))], pop[popId], pop[popId].chromosome.length, applyunroll, maxwidth);
            mutation(looprankSize, loopfactors, exploreParams[Math.floor(Math.random()*(exploreParamSize-0.1))], pop[popId], pop[popId].chromosome.length, applyunroll, maxwidth);
            mutation(looprankSize, loopfactors, exploreParams[Math.floor(Math.random()*(exploreParamSize-0.1))], pop[popId], pop[popId].chromosome.length, applyunroll, maxwidth);
          }
          vezes++;
        }
        else {
          break;
        }
      } while (vezes < vezesTot);

      if (vezes < vezesTot) {

        if(total_steps >= iterations) {
          //println("Breaks from Generation");
          break;
        }

        // Individual's evaluation
        //-------------------------------------------------------------------
    
        // Apply code transformations
        optimLevel = pop[popId].chromosome.filter(isnooptim).join(" ");
        pop[popId].fitness = compile_execute_and_report(optimLevel);

        if(check_sequence_is_valid(pop[popId].fitness) == false) {
          pop[popId].fitness = Number.MAX_VALUE;
          pop[popId].chromosomeSize = maxwidth;
         } else {
          // Tranformations quantification (secundary cost function)
          pop[popId].chromosomeSize = pop[popId].chromosome.length;
        }

        total_steps++;
  
        // Store individual in historical array
        histPop[histSize] = indiv_copy(pop[popId]);
        histSize++;
        novo++; // Determines novelty

        // Debug code
        //println(pop[popId].fitness + ";" + pop[popId].chromosomeSize + ";" + pop[popId].chromosome.join(","));
        //-------------------------------------------------------------------

      }
      else {
        // Force individual remove for next generation
        pop[popId].fitness = Number.MAX_VALUE;
        pop[popId].chromosomeSize = maxwidth;
      }
    }

    // Elitism reinsertion (sort and cut)
    pop.sort(by('fitness', by('chromosomeSize')));

    bestlatency = pop[0].fitness;

    //******************  STOP CRITERION *******************
/*
    // STOP CRITERION: Improvement between generations
    if ((bestlatency - pop[0].fitness) <= deltaMin || novo == 0) {
      //println("a diferenca eh: " + (bestlatency - pop[0].fitness) + " e o valor de novo eh: " + novo);
      counterSpeedup++;
    }
    else {
      counterSpeedup = 1;
    }
    
    if (counterSpeedup == maxCount) {
      //println("*** STOP CRITERION: " + maxCount + " evolutions without improvement ***");
      break;
    }
*/


  }

  // Print historical array
//  for (popId = 0; popId < histSize; popId++) {
//    //println(histPop[popId].fitness + ";" + histPop[popId].chromosomeSize + ";" + histPop[popId].chromosome.join(",") + ";" + histPop[popId].loopFactors.join(",") + ";" + loopranks.join(","));
//  }

  bestSeqLatency = bestlatency;
  bestSeq = pop[0].chromosome;


end
